<!doctype html>
<html>
  <head>
  <meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
  <script type="text/javascript" src="js/Tone.min.js"></script>
	<script src="js/bt.js"></script>
	<script src="js/lc-playlist-textinput.js"></script>
	<script src="js/translator3.js"></script>
	<script src="js/nexusUI.js"></script>
	<link href='http://fonts.googleapis.com/css?family=Anonymous+Pro:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="css/coding.css">
    <link href="./jcubic/css/jquery.terminal.css" rel="stylesheet"/>
    <script src="./jcubic/js/jquery-1.7.1.min.js"></script>
    <script src="./jcubic/js/jquery.mousewheel-min.js"></script>
    <script src="./jcubic/js/jquery.terminal-min.js"></script>
		<script src="js/jquery-ui.js"></script>
  </head>
  <body>

	<h1>McLuhan.js *Environment*</h1>

	<div id="main">

  	<canvas id="presence" style="position:absolute;top:0px"></canvas>

		<div id="playlist"></div>

		<div id="terminal" style="z-index:2;text-align:left;position:absolute;bottom:0px;width:100%"></div>

	</div>

	<canvas nx="trace"></canvas>

	<div id="poemvis"></div>

	<script>

			//m.deck(8)
			//
			var m = {
				variables: []
			}

			nx.onload = function() {

				nx.colorize("black")
				trace1.nodeSize = 8
				trace1.on('*',function(data) {
					// done so that the Array object keeps its reference within all the generators. I.e. is not made into a new object.
					while (_Gesture1Buffer.length > 0) {
						_Gesture1Buffer.pop()
					}
					for (var i=0;i<data.path.length;i++) {
						_Gesture1Buffer[i] = data.path[i]
					}	

					// will need to set all generators.... 
					// maybe gens should all go to some central array?
					// or maybe they always look to some central variable <<<variable!
					// that way, if I change that one variable, they will receive it
					// instead of having to call 'setBuffer' on each gesture in kind.
				})

			}

		  var current = {
    		wall: "",
    		media: "",
    		type: "",
    		params: ""
    	}

    	var black = {test: "thing"}

    	var local = {
    		context: "black",
    		walls: [],
    		nextWall: function() {
    			var colori = local.walls.indexOf(local.context)
    			colori++
    			if (colori >= local.walls.length) {
    				colori = 0
    			}
    			return local.walls[colori];
    		},
    		intervals: {}
    	}

			$('#terminal').terminal(function(command) {
           	
       	try {

       		var info = Translate.toCode(command)
       		playlist.add(command, info, local.context)

       	} catch(e) {

       		console.log("EVAL ERROR", e);

       	}

       	return false;
           	
	    }, {
        completion: ["add"],
        greetings: "",
        prompt: "~ ",
        keypress: function(e) {
        	// ~
        	if (e.which==126) {
        		var nextcolor = rainbow[colorcount.tick()]
        		//distant.walls[nextcolor] = new wall("line")
        		distant.createWall(nextcolor);
        		local.context = nextcolor
        		local.walls.push(nextcolor)
        		$("#terminal").terminal().set_command("")
        		$("#terminal .cmd").css("color", local.context)
        		return false;
        	}
        	// `
        	if (e.which==96) {
        		local.context = local.nextWall();
        		//$("#terminal").terminal().set_command("")
        		$("#terminal .cmd").css("color", local.context)
        		return false;
        	}
        //  socket.emit('typing',$("#terminal .cmd span")[1].innerHTML)
        }
	    });

		var rainbow = ["red", "orange", "green", "blue", "purple" ]

		var walls = []




		/* INSTANCES */

		var playlist = new LCPlaylist("playlist", function(data) {
			
			// data.index, data.command, data.event
			// data.duration, data.reference
		


			if (!data.duration) {

				//happens distantly
				data.gencode = createGens(data.index,data.code)
				if (data.reference) {
					with (m.variables[data.reference]) {
						eval(data.gencode)
					}
				} else {
					//with (eval(data.wall)) {
						m.variables[data.index] = eval(data.gencode)
						console.log(m.variables[data.index])
						console.log(this)
					//}
				}
					
			} else {
				
				local.intervals["line"+data.index] = interval(data.duration,function(data) {
					console.log(this)
					this.ping(data)
				}.bind(playlist,data))

				// happens distantly
				data.gencode = createGens(data.index,data.code)
				distant.intervals["line"+data.index] = interval(data.duration,function(data) {
						// distant
						if (data.reference) {
							with (m.variables[data.reference]) {
								//happens distantly
								eval(data.gencode)
							}
						} else {
							//with (eval(data.wall)) {
								m.variables[data.index] = eval(data.gencode)
								console.log(m.variables[data.index])
							//}
						}
				}.bind(this,data))
				//poemvis.add(data)
				
			}
	

		}.bind(window))

		var poemvis = new PoemVis("poemvis")





		var sine = new Tone.SimpleSynth().toMaster()
		var poly = new Tone.PolySynth(30, Tone.SimpleSynth).toMaster();

		sine.play = function(note) {

			sine.triggerAttackRelease(note,0.1)

		}
		poly.play = function(note) {

			poly.triggerAttackRelease(note,0.1)

		}





/*
		window.bounce = function(scale) {
			// what will need to happen in here?
			// 
			// new Bounce
			// or new Gesture
			// or new Generator
			/*
			 text in would be:
			 sine.play(random(20)+200) @ 200
			 sine.play(choice(20,40,60)+200) @ 200
			 sine.play(bounce(0,200)+200) @ 200
			 sine.play(A(0,200)+200) @ 200
			 // bounce is over 16 or 32 steps?
			
			 result would be....
			 sine.play(_bounce1+200)
			 sine.play(line1.gens[0]()+200)

			 but would be great to be able to compound like:
			 sine.play(choice(bounce(0,100),bounce(100,0))+200) @ 200

			 could also markov:
			 sine.play(markov1(0,0.1,0.2,0.3)) @ markov1(100,200,300,400)
			 markov1 could have built-in probabilities for each argument.
			 all of same markov's within a line could be tied together. thatd be nice!

			 so....
			 random, choice don't need gens
			 bounce, gesture, markov do need gens
			 bounce should not have ability for choice() or rand() arg
			 neither should gesture
			 neither should markov. so! fine.

			 can search for index of bounce(, gesture1x(, markov(
			 jest(0,50)

			 orrrr could.... have the first bounce() push some properties into distant.gens, then act on those properties each time.
			 but how would bounce know which properties were its?

			
		}
		
*/
	    



	    /* Ben Library */

	    var Counter = function(limit) {
	    	this.max = 0;
	    	this.current = -1;
	    	this.tick = function() {
	    		this.current++;
	    		if (this.current>=this.limit) {
	    			this.current = 0;
	    		}
	    		return this.current;
	    	}
	    	this.downtick = function() {
	    		this.current--;
	    		if (this.current <= this.limit) {
	    			this.current = this.limit-1;
	    		}
	    		return this.current;
	    	}
	    }

	    var colorcount = new Counter(rainbow.length);




	    /* distant */

    	var distant = {
    		walls: {},
    		createWall: function(nextcolor) {
    			window[nextcolor] = new wall("line")
    		},
    		intervals: {},
    		gens: {}
    	}

    	
    	var createGens = function(index,code) {
    		var gennames = ["bounce","gesture","markov"]
    		distant.gens["line"+index] = []
    		for (var i=0;i<code.length;i++) {
    			for (var j=0;j<gennames.length;j++) {
    				if (code.slice(i).indexOf(gennames[j]+"(")==0) {
    					var end = code.slice(i).indexOf(")")+i+1
    					var linekey = "line"+index
    					distant.gens[linekey].push({
    						orig: code.slice(i,end), 
    						type: gennames[j],
    						start: i,
    						end: end
    					})
    					var genIndex = distant.gens[linekey].length - 1
    					code = code.replace(distant.gens[linekey][genIndex].orig,'distant.gens["'+linekey+'"]['+genIndex+'].generator.tick()')
    				}
    			}
    		}
    		for (var i=0;i<distant.gens["line"+index].length;i++) {
    			distant.gens["line"+index][i].generator = eval("new " + distant.gens["line"+index][i].orig[0].toUpperCase() + distant.gens["line"+index][i].orig.slice(1))
    		}
    		return code
    	}












   

    	/* NEED TO BE ENCAPSULATED (in musicians toolkit?) */




    	/* BOUNCE*/

			function Bounce(lower,upper) {

				this.value = lower

				this.upper = Math.max(lower,upper)
				this.lower = Math.min(lower,upper)

				this.beats = 16

				this.step = (this.upper - this.lower) / this.beats
				this.direction = 1

				this.tick = function() {
					this.value += this.direction * this.step
					if (this.value > this.upper) {
						this.direction = -1
						this.value = this.upper
					} else if (this.value < this.lower) {
						this.direction = 1
						this.value = this.lower
					}
					return this.value
				}
			}





			/* GESTURE */

			_Gesture1Buffer = [
					{x: 0, y: 1 },
					{x: 1, y: 0 }
			]

			var Gesture = function(xlow,xhigh) {

				var ylow = 0
				var yhigh = 0

				this.buffer = _Gesture1Buffer
			
				this.bufferIndex = 0
				this.speed = 1
				this.limit = 100

				this.range = {
					x: [ xlow ? xlow : 0 , xhigh ? xhigh : 1 ],
					y: [ ylow ? ylow : 0 , yhigh ? yhigh : 1 ]
				}

			}

			Gesture.prototype.setBuffer = function(buff) {
				this.buffer = buff ? buff : this.buffer
				
			}

			Gesture.prototype.kill = function() {
			}

			Gesture.prototype.tick = function() {

				this.bufferIndex += this.speed
				this.bufferIndex %= this.limit

				var interval = this.limit / this.buffer.length;

				var lowerIndex = Math.floor(this.bufferIndex/interval)
				var upperIndex = lowerIndex + 1

				upperIndex %= this.buffer.length

				var interpDistance = (this.bufferIndex - lowerIndex*interval) / interval

				var x = interp(interpDistance, this.buffer[lowerIndex].x,this.buffer[upperIndex].x)
				var y = interp(interpDistance, this.buffer[lowerIndex].y,this.buffer[upperIndex].y)

				x *= scale(x,0,1,this.range.x[0],this.range.x[1])

				return x

			}

			/* PATTERN */




			/* WANDER */



//what kind of code?
//
//major(wander(20,70))
//markov(majorscale)
//markov(majorscale) .... really don't need to do 'major' stuff yet. going to focus on samples.
//
//pattern(0,10,8) could mean create a dream6 style pattern out of 8 divisions of 0 and 10
//wander(0,10) could mean wander by step (1? 0.1?) between 0 and 10





 /* LOOP shorthand...

1 ~ pian = [] 
2 ~ -l 10 pian.push(hear("pno"))
3 ~ -l 10 pian[i].play(r(2)) @ 500

1 ~ pian = [] 
2 ~ -l 10 pian.push(hear("pno"))
3 ~ pian.each("play(600)") @ 500

1 ~ [] 
2 ~ -l 10 1 push(hear("pno"))
3 ~ 1 each("play(600)") @ 500

1 ~ []
2 ~ 1 push(hear("piano")) @ 0 10
3 ~ 1 play(r(1,2)) @ 0 10 @ 500


would you ever do -l lineNum code....?

1 ~ explore("montana")
2 ~ 1 info() -l ...






so.....


1 ~ piano = []
2 ~ -l 10 piano[i] = hear("pno")
3 ~ 1 each("play(600)") @ 500




-1 wraps a loop around the code
for (var i=0;i<10;i++) {
	piano[i] = hear("pno"))
}

-1 wraps a loop around the code
every 500ms:
for (var i=0;i<10;i++) {
	piano[i].play(r(1,2))
}

loops cannot be used accurately with: gesture, markov, bounce
*/




	</script>

  </body>
</html>